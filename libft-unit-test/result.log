ft_memset:     [OK] [OK] [OK] [OK] [OK] [OK] [OK] 
ft_bzero:      [OK] [OK] [OK] [OK] 
ft_memcpy:     [OK] [OK] [OK] [OK] [OK] [OK] [OK] [OK] [OK] [OK] [CRASH] 
[crash]: your memcpy does not behave well with NULL as both params with size
Test code:
	ft_memcpy(((void*)0), ((void*)0), 3);


ft_memccpy:    [MISSING]
ft_memmove:    [OK] [OK] [OK] [OK] [OK] [OK] [OK] [OK] [OK] [NO CRASH] [NO CRASH] [OK] [OK] [OK] 
[no crash]: your memmove does not segfault when null params is sent
Test code:
	char b[0xF0];

	ft_memmove(((void*)0), b, 5);


[no crash]: your memmove does not segfault when null params is sent
Test code:
	char b[0xF0];

	ft_memmove(b, ((void*)0), 5);


ft_memchr:     [OK] [OK] [OK] [OK] [OK] [OK] [OK] [OK] 
ft_memcmp:     [OK] [OK] [OK] [OK] [OK] [OK] [OK] [OK] [OK] [OK] 
ft_strlen:     [OK] [OK] [OK] [OK] [OK] [OK] [OK] [OK] [OK] 
ft_isalpha:    [FAILED] 
[fail]: your isalpha just doesn't work, REALLY ?!
Test code:
	int i;

	i = -1;
	while (i < 530)
	{
		if (!!ft_isalpha(i) != !!((*__ctype_b_loc ())[(int) ((i))] & (unsigned short int) _ISalpha))
			exit(TEST_FAILED);
		i++;
	}
	exit(TEST_SUCCESS);

Diffs:


ft_isdigit:    [FAILED] 
[fail]: your isdigit just doesn't work, REALLY ?!
Test code:
	int i;

	i = -1;
	while (i < 530)
	{
		if (!!ft_isdigit(i) != !!((*__ctype_b_loc ())[(int) ((i))] & (unsigned short int) _ISdigit))
			exit(TEST_FAILED);
		i++;
	}
	exit(TEST_SUCCESS);

Diffs:


ft_isalnum:    [OK] 
ft_isascii:    [FAILED] 
[fail]: your isascii just doesn't work, REALLY ?!
Test code:
	int i;

	i = -1;
	while (i < 530)
	{
		if (!!ft_isascii(i) != !!(((i) & ~0x7f) == 0))
		{
			exit(TEST_FAILED);
		}
		i++;
	}
	exit(TEST_SUCCESS);

Diffs:
     isascii: |0|
  ft_isascii: |1|
param: (256)

ft_isprint:    [FAILED] 
[fail]: your isprint just doesn't work, REALLY ?!
Test code:
	int i;

	i = -1;
	while (i < 530)
	{
		if (!!ft_isprint(i) != !!((*__ctype_b_loc ())[(int) ((i))] & (unsigned short int) _ISprint))
		{
			exit(TEST_FAILED);
		}
		i++;
	}
	exit(TEST_SUCCESS);

Diffs:
     isprint: |0|
  ft_isprint: |16384|
param: (288)

ft_toupper:    [OK] 
ft_tolower:    [OK] 
ft_strchr:     [OK] [OK] [OK] [OK] [OK] [OK] [OK] [OK] [OK] [OK] 
ft_strrchr:    [OK] [OK] [OK] [OK] [OK] [OK] [CRASH] [OK] 
[crash]: your strrchr crash because it read too many bytes or attempt to write on s !
Test code:
	char *src = electric_alloc(10);

	strcpy(src, "123456789");
	ft_strrchr(src, 'a');
	src = electric_alloc_rev(10);
	strcpy(src, "123456789");
	ft_strrchr(src, 'a');
	exit(TEST_SUCCESS);


ft_strncmp:    [OK] [OK] [OK] [OK] [OK] [OK] [OK] [OK] [OK] [OK] [OK] [OK] [OK] [OK] 
ft_strlcpy:    [OK] [OK] [OK] [OK] [OK] [OK] [OK] 
ft_strlcat:    [OK] [OK] [OK] [OK] [OK] [OK] [OK] [OK] [OK] [OK] [OK] [OK] [CRASH] 
[crash]: your strlcat crush when null parameter is sent with a size of 0
Test code:
	char b[0xF] = "nyan !";

	ft_strlcat(((void*)0), b, 0);
	exit(TEST_SUCCESS);


ft_strnstr:    [OK] [OK] [OK] [OK] [OK] [OK] [OK] [OK] [OK] [OK] [FAILED] [CRASH] [OK] [OK] [OK] 
[fail]: your strnstr does not work with the same pointer and an exceeding length value
Test code:
	char *s1 = "A";
	size_t max = strlen(s1) + 1;
	char *i1 = strnstr(s1, s1, max);
	char *i2 = ft_strnstr(s1, s1, max);

	if (i1 == i2)
		exit(TEST_SUCCESS);
	exit(TEST_FAILED);

Diffs:
     strnstr: |A|
  ft_strnstr: |(null)|

[crash]: your strnstr crashes because it read too many bytes !
Test code:
	const size_t size = 20;
	char *s1 = electric_alloc(size);
	char *s2 = electric_alloc(size);

	strcpy(s1, "is there a nyacat ?");
	strcpy(s2, "is there a nyacat ?");
	ft_strnstr(s1, s2, size);
	exit(TEST_SUCCESS);


ft_atoi:       [OK] [OK] [OK] [OK] [OK] [OK] [FAILED] [OK] [OK] [OK] [OK] [OK] [KO] [KO] [OK] [OK] [OK] [NO CRASH] 
[fail]: your atoi is not working with non space invisible char
Test code:
	char *n = "\e06050";
	int i1 = atoi(n);
	int i2 = ft_atoi(n);

	if (i1 == i2)
		exit(TEST_SUCCESS);
	exit(TEST_FAILED);

Diffs:
        atoi: |0|
     ft_atoi: |6050|

[KO]: your atoi does not work with over long max value
Test code:
	char n[40] = "99999999999999999999999999";
	int i1 = atoi(n);
	int i2 = ft_atoi(n);

	if (i1 == i2)
		exit(TEST_SUCCESS);
	exit(TEST_KO);

Diffs:
        atoi: |-1|
     ft_atoi: |-469762049|

[KO]: your atoi does not work with over long min value
Test code:
	char n[40] = "-99999999999999999999999999";
	int i1 = atoi(n);
	int i2 = ft_atoi(n);

	if (i1 == i2)
		exit(TEST_SUCCESS);
	exit(TEST_KO);

Diffs:
        atoi: |0|
     ft_atoi: |469762049|

[no crash]: your atoi does not work with the plus sign and spaces
Test code:
	ft_atoi(((void*)0));


ft_calloc:     [OK] [OK] [OK] [OK] [OK] 
ft_strdup:     [OK] [OK] [CRASH] [OK] [OK] [OK] [OK] 
[crash]: your strdup don't work with empty string
Test code:
	char *str;
	char *tmp = "";

	str = ft_strdup(tmp);
	if (strcmp(str, tmp))
		exit(TEST_FAILED);
	free(str);
	exit(TEST_SUCCESS);


ft_substr:     [OK] [OK] [OK] [OK] [OK] [OK] [OK] [OK] {not protected}[FAILED] 
[fail]: your substr does not work when start >= ft_strlen(s)
Test code:
	char *str = "01234";
	size_t size = 10;
	char *ret = ft_substr(str, 10, size);

	if (!strncmp(ret, "", 1))
	{
		free(ret);
		exit(TEST_SUCCESS);
	}
	free(ret);
	exit(TEST_FAILED);

Diffs:
      substr: ||
   ft_substr: | strjoin d|

ft_strjoin:    [OK] [OK] [OK] [OK] [OK] {not protected}
ft_strtrim:    [OK] [OK] [OK] [CRASH] [CRASH] [OK] [OK] [CRASH] [OK] {not protected}
[crash]: your strtrim does not work with full blank input
Test code:
	char *s1 = "  \t \t \n   \n\n\n\t";
	char *s2 = "";
	char *ret = ft_strtrim(s1, " \n\t");

	if (!strcmp(ret, s2))
		exit(TEST_SUCCESS);
	exit(TEST_FAILED);


[crash]: your strtrim does not work with empty input
Test code:
	char *s1 = "";
	char *s2 = "";
	char *ret = ft_strtrim(s1, " \n\t");

	if (!strcmp(ret, s2))
		exit(TEST_SUCCESS);
	exit(TEST_FAILED);


[crash]: you dont protect your malloc return
Test code:
	char *s1 = "   \t  \n\n \t\t  \n\n\nHello \t  Please\n Trim me !\n   \n \n \t\t\n  ";

	char *ret = ft_strtrim(s1, " \n\t");
	if (ret == ((void*)0))
		exit(TEST_SUCCESS);
	exit(TEST_FAILED);


ft_split:      [MISSING]
ft_itoa:       [MISSING]
ft_strmapi:    [MISSING]
ft_putchar_fd: [MISSING]
ft_putstr_fd:  [MISSING]
ft_putendl_fd: [MISSING]
ft_putnbr_fd:  [MISSING]
ft_lstnew:     [MISSING]
ft_lstadd_front: [MISSING]
ft_lstsize:    [MISSING]
ft_lstlast:    [MISSING]
ft_lstadd_back:[MISSING]
ft_lstdelone:  [MISSING]
ft_lstclear:   [MISSING]
ft_lstiter:    [MISSING]
ft_lstmap:     [MISSING]
